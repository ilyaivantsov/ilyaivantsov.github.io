<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Matrix Camera ASCII</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #0f0;
      font-family: monospace;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
    #startBtn {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0,0,0,0.8);
      color: #00ff88;
      font: 18px/1.4 monospace;
      z-index: 10;
    }
    #startBtn button {
      padding: 12px 20px;
      background: #001a00;
      border: 1px solid #00ff88;
      color: #00ff88;
      border-radius: 8px;
      cursor: pointer;
    }
    #err {
      position: fixed;
      bottom: 8px; left: 8px;
      right: 8px;
      color: #f55;
      font: 12px/1.4 monospace;
      opacity: .9;
      pointer-events: none;
    }
    #controls {
      position: fixed;
      top: 8px; right: 8px;
      color: #00ff88;
      font: 11px/1.3 monospace;
      opacity: .8;
      pointer-events: none;
      background: rgba(0,0,0,0.3);
      padding: 8px;
      border-radius: 4px;
    }
    .key {
      color: #88ff88;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="startBtn"><button>Start camera</button></div>
  <div id="err" aria-live="polite"></div>
  <div id="controls">
    <span class="key">R</span> - toggle rain effect<br>
    <span class="key">E</span> - toggle enhancement<br>
    <span class="key">F</span> - toggle fullscreen
  </div>
  <canvas id="q"></canvas>

  <script>
    // --- Основные узлы/контексты ---
    const canvas = document.getElementById('q');
    const ctx = canvas.getContext('2d', { alpha: false });
    const startOverlay = document.getElementById('startBtn');
    const startButton  = startOverlay.querySelector('button');
    const errBox = document.getElementById('err');

    // Скрытое <video> для потока камеры
    const video = document.createElement('video');
    video.playsInline = true; // iOS
    video.muted = true;       // авто-воспроизведение
    video.autoplay = true;    // авто-воспроизведение

    // Буфер низкого разрешения для сэмплинга яркости (по размеру сетки символов)
    const sample = document.createElement('canvas');
    const sctx   = sample.getContext('2d', { willReadFrequently: true });

    // --- Настройки ASCII/матрицы ---
    const FONT_SIZE = 8; // уменьшен для большей детализации (px, в CSS-пикселях)
    // Оптимизированный набор символов по визуальной плотности (от светлого к темному)
    const CHARSET = " .`',^:;~\"-!|\\/()*+?><}{][Il1ifjrxnuvczXYUJCLQ0OZmwqpdbkhao#MW&8%B@$█";
    const FPS = 30;        // ограничение кадров
    const FADE_ALPHA = 0.04; // уменьшен для меньшего замыливания
    
    // Настройки качества изображения
    const CONTRAST = 1.3;   // увеличение контрастности
    const BRIGHTNESS = 0.1; // небольшое увеличение яркости
    const GAMMA = 0.8;      // гамма-коррекция для лучшей видимости деталей
    
    // Режимы отображения
    let showRain = true;      // можно отключить дождь для лучшей читаемости
    let enhancedMode = true;  // улучшенная обработка изображения

    let dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    let W = 0, H = 0, COLS = 0, ROWS = 0;

    // Позиции "дождя" для каждого столбца (в строках сетки)
    let drops = [];

    // Градиент для неонового зелёного
    let neonGradient = null;

    function setCanvasSize() {
      dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width  = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // работать в CSS-пикселях
      W = w; H = h;

      // Сетка символов
      COLS = Math.floor(W / FONT_SIZE);
      ROWS = Math.floor(H / FONT_SIZE);

      // Буфер сэмплинга (по сетке)
      sample.width  = COLS;
      sample.height = ROWS;

      // Градиент вдоль вертикали
      neonGradient = ctx.createLinearGradient(0, 0, 0, H);
      neonGradient.addColorStop(0.00, '#003300');
      neonGradient.addColorStop(0.35, '#00aa44');
      neonGradient.addColorStop(0.65, '#00dd55');
      neonGradient.addColorStop(1.00, '#00ff66');

      // Инициализация «дождя»
      drops = new Array(COLS).fill(0).map(() => Math.floor(Math.random() * ROWS) * -1);
      ctx.font = `${FONT_SIZE}px monospace`;
      ctx.textBaseline = 'top';
    }

    window.addEventListener('resize', setCanvasSize);

    // --- Работа с камерой ---
    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { 
            facingMode: 'user', 
            width: { ideal: 1920, min: 1280 }, 
            height: { ideal: 1080, min: 720 },
            frameRate: { ideal: 30 }
          },
          audio: false
        });
        video.srcObject = stream;

        // Ждём метаданные, чтобы появились videoWidth/Height
        await new Promise((res) => {
          if (video.readyState >= 2) res();
          else video.onloadedmetadata = res;
        });

        await video.play().catch(() => {}); // iOS иногда требует жест
        startOverlay.style.display = 'none';
        setCanvasSize();
        lastFrameTime = 0;
        requestAnimationFrame(loop);
      } catch (e) {
        errBox.textContent = 'Ошибка доступа к камере: ' + (e && e.message ? e.message : e);
      }
    }

    startButton.addEventListener('click', startCamera);
    // Попробовать авто-старт (в десктопе/https обычно сработает)
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      // Позволим пользователю видеть кнопку; автозапуск попытаемся параллельно
      startCamera().catch(() => {});
    }

    // --- Улучшенная обработка изображения ---
    function enhanceImage(luma01) {
      if (!enhancedMode) return luma01;
      
      // Применяем яркость и контрастность
      let enhanced = (luma01 + BRIGHTNESS) * CONTRAST;
      
      // Гамма-коррекция для лучшей видимости деталей в средних тонах  
      enhanced = Math.pow(Math.max(0, Math.min(1, enhanced)), GAMMA);
      
      return enhanced;
    }

    // --- Маппинг яркости -> символ ---
    function charForLuma(luma01) {
      // Применяем улучшения изображения
      const enhanced = enhanceImage(luma01);
      
      // Нелинейное маппинг для лучшего использования диапазона символов
      const curved = Math.pow(enhanced, 0.7); // S-образная кривая
      
      const i = Math.min(CHARSET.length - 1, Math.max(0, Math.floor(curved * (CHARSET.length - 1))));
      return CHARSET[i];
    }

    // Получить массив яркостей (0..1) для всей сетки из текущего кадра видео
    function getGridLumas() {
      // Отрисовываем текущий видеокадр в маленький буфер размером COLS x ROWS
      // это эффективно масштабирует и «усредняет» пиксели под одну «ячейку символа»
      // Сохраняем пропорции: заполняем весь буфер (cover)
      const vW = video.videoWidth || 640;
      const vH = video.videoHeight || 480;
      const srcRatio = vW / vH;
      const dstRatio = COLS / ROWS;

      let sx = 0, sy = 0, sw = vW, sh = vH;
      if (dstRatio > srcRatio) {
        // раскладываем по ширине — обрезаем по высоте
        sh = Math.floor(vW / dstRatio);
        sy = Math.floor((vH - sh) / 2);
      } else {
        // раскладываем по высоте — обрезаем по ширине
        sw = Math.floor(vH * dstRatio);
        sx = Math.floor((vW - sw) / 2);
      }

      // Улучшенное качество ресайза для лучшей четкости
      sctx.imageSmoothingEnabled = true;
      sctx.imageSmoothingQuality = 'high';
      sctx.drawImage(video, sx, sy, sw, sh, 0, 0, COLS, ROWS);
      const img = sctx.getImageData(0, 0, COLS, ROWS).data;

      const lumas = new Float32Array(COLS * ROWS);
      // Вычисляем яркость по Rec. 601: 0.299R + 0.587G + 0.114B
      for (let i = 0, p = 0; i < img.length; i += 4, p++) {
        const r = img[i], g = img[i+1], b = img[i+2];
        lumas[p] = (0.299*r + 0.587*g + 0.114*b) / 255;
      }
      return lumas;
    }

    // --- Основной рендер ---
    let lastFrameTime = 0;
    function loop(ts) {
      requestAnimationFrame(loop);

      // Ограничение FPS
      if (ts - lastFrameTime < (1000 / FPS)) return;
      lastFrameTime = ts;

      if (!COLS || !ROWS) return;

      // 1) Затухание только шлейфов «дождя» (предыдущего кадра)
      //    Потом перерисуем базовое ASCII-изображение полностью.
      if (showRain) {
        ctx.fillStyle = `rgba(0,0,0,${FADE_ALPHA})`;
        ctx.fillRect(0, 0, W, H);
      } else {
        // В режиме без дождя очищаем полностью для лучшей четкости
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, W, H);
      }

      // 2) Базовое ASCII-изображение из камеры (полностью, без альфы)
      const lumas = getGridLumas();
      ctx.fillStyle = neonGradient;
      ctx.font = `${FONT_SIZE}px monospace`;
      ctx.textBaseline = 'top';

      // Чтобы быстрее — проходим по строкам
      for (let y = 0; y < ROWS; y++) {
        const yPx = y * FONT_SIZE;
        for (let x = 0; x < COLS; x++) {
          const l = lumas[y * COLS + x];
          const ch = charForLuma(l);
          ctx.fillText(ch, x * FONT_SIZE, yPx);
        }
      }

      // 3) «Дождь» из букв поверх (только если включен)
      if (showRain) {
        for (let x = 0; x < COLS; x++) {
          let y = drops[x];
          // Уменьшен шанс появления капель для менее навязчивого эффекта
          if (y >= 0 && y < ROWS && Math.random() > 0.5) {
            const l = lumas[(y * COLS) + x];
            const ch = charForLuma(l);

            // Голова капли - яркая
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = '#aaffaa';
            ctx.fillText(ch, x * FONT_SIZE, y * FONT_SIZE);
            ctx.restore();

            // Более короткий хвост для меньшего засорения изображения
            const tail = 3;
            for (let t = 1; t <= tail; t++) {
              const yy = y - t;
              if (yy < 0) break;
              const lt = lumas[(yy * COLS) + x];
              const cht = charForLuma(lt);
              const alpha = Math.max(0.05, 1 - t / (tail + 1));
              ctx.save();
              ctx.globalAlpha = alpha * 0.6; // Более прозрачный хвост
              ctx.fillStyle = neonGradient;
              ctx.fillText(cht, x * FONT_SIZE, yy * FONT_SIZE);
              ctx.restore();
            }
          }

          // Сдвиг капли вниз
          drops[x] = y + 1;

          // Реже перезапускаем капли для меньшего количества "дождя"
          if (drops[x] * FONT_SIZE > H && Math.random() > 0.985) {
            drops[x] = Math.floor(-Math.random() * ROWS * 0.8);
          }
        }
      }
    }

    // --- Управление клавишами ---
    document.addEventListener('keydown', (e) => {
      switch(e.key.toLowerCase()) {
        case 'r':
          showRain = !showRain;
          console.log('Rain effect:', showRain ? 'ON' : 'OFF');
          break;
        case 'e':
          enhancedMode = !enhancedMode;
          console.log('Enhanced mode:', enhancedMode ? 'ON' : 'OFF');
          break;
        case 'f':
          if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
          } else {
            document.exitFullscreen();
          }
          break;
      }
    });
  </script>
</body>
</html>
